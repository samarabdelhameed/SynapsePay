# ğŸš€ SynapsePay - Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©

## ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©

Ù‡Ø°Ø§ Ø§Ù„Ø¯Ù„ÙŠÙ„ ÙŠÙˆØ¶Ø­ Ø®Ø·ÙˆØ§Øª ØªØ·ÙˆÙŠØ± Ù…Ø´Ø±ÙˆØ¹ SynapsePay Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ù† Ø§Ù„ØµÙØ± Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªØ´ØºÙŠÙ„.

---

## ğŸ“Š ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ

### âœ… Ù…Ø§ ØªÙ… Ø¥Ù†Ø¬Ø§Ø²Ù‡ (Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©)

| Ø§Ù„Ù…ÙƒÙˆÙ† | Ø§Ù„Ø­Ø§Ù„Ø© | Ø§Ù„Ù…Ù„ÙØ§Øª |
|--------|--------|---------|
| **Anchor Programs Structure** | âœ… Ù…ÙˆØ¬ÙˆØ¯ | `programs/synapsepay-payments/src/lib.rs` |
| **X402 Library** | âœ… Ù…ÙˆØ¬ÙˆØ¯ | `packages/x402-solana/src/` (5 files) |
| **Facilitator Server Structure** | âœ… Ù…ÙˆØ¬ÙˆØ¯ | `apps/x402-facilitator/src/server.ts` |
| **Resource Server Structure** | âœ… Ù…ÙˆØ¬ÙˆØ¯ | `apps/resource-server/src/server.ts` |
| **Frontend (Web)** | âœ… Ø´ØºØ§Ù„ | `apps/web/` (Full React app) |
| **IoT Components** | âœ… ÙƒØ§Ù…Ù„ | `apps/web/src/components/device/` |

### âš ï¸ Ù…Ø§ ÙŠØ­ØªØ§Ø¬ Ø§Ø³ØªÙƒÙ…Ø§Ù„

| Ø§Ù„Ù…ÙƒÙˆÙ† | Ø§Ù„Ø­Ø§Ù„Ø© | Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© |
|--------|--------|----------|
| **Anchor Instructions (Rust)** | âš ï¸ Ø¬Ø²Ø¦ÙŠ | ğŸ”´ Ø¹Ø§Ù„ÙŠØ© |
| **Backend API Routes** | âš ï¸ Ø¬Ø²Ø¦ÙŠ | ğŸ”´ Ø¹Ø§Ù„ÙŠØ© |
| **Hooks (React)** | âŒ ÙØ§Ø±Øº | ğŸŸ¡ Ù…ØªÙˆØ³Ø·Ø© |
| **Real Integration** | âŒ Ù†Ø§Ù‚Øµ | ğŸ”´ Ø¹Ø§Ù„ÙŠØ© |
| **Tests** | âŒ Ù†Ø§Ù‚Øµ | ğŸŸ¡ Ù…ØªÙˆØ³Ø·Ø© |

---

## ğŸ¯ Ø®Ø·Ø© Ø§Ù„ØªÙ†ÙÙŠØ° - Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø§Ù„ØµØ­ÙŠØ­

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ØªØ±ØªÙŠØ¨ Ø§Ù„ØªÙ†ÙÙŠØ° (Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„ Ù„Ù„Ø£Ø¹Ù„Ù‰)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 6: Testing & Demo                          â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
    â”‚    E2E Tests â†’ Integration Tests â†’ Demo Video â†’ Submission          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 5: Frontend Integration                    â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚
    â”‚    usePayment Hook â†’ PaymentModal â†’ Agent Execution Flow            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 4: Backend Services                        â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”‚
    â”‚    Facilitator API â†’ Resource Server â†’ Actions API                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 3: X402 Protocol Library                   â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”‚
    â”‚    Payload Encoding â†’ Signature Verification â†’ Middleware           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 2: Anchor Programs                         â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
    â”‚    Registry â†’ Payments â†’ Scheduler                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â–²
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    Phase 1: Environment Setup                       â”‚
    â”‚                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
    â”‚    Solana CLI â†’ Anchor â†’ Dependencies â†’ Environment Variables       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

# ğŸ“¦ Phase 1: Environment Setup
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 30 Ø¯Ù‚ÙŠÙ‚Ø©

### Step 1.1: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª

```bash
# ØªØ£ÙƒØ¯ Ù…Ù† ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£Ø¯ÙˆØ§Øª
node --version       # ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 18+
bun --version        # Ø£Ùˆ npm
solana --version     # ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 1.17+
anchor --version     # ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 0.29+
```

### Step 1.2: ØªØ«Ø¨ÙŠØª Solana CLI Ùˆ Anchor (Ø¥Ø°Ø§ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯)

```bash
# ØªØ«Ø¨ÙŠØª Solana CLI
sh -c "$(curl -sSfL https://release.solana.com/v1.18.4/install)"

# ØªØ«Ø¨ÙŠØª Anchor
cargo install --git https://github.com/coral-xyz/anchor avm --locked --force
avm install latest
avm use latest
```

### Step 1.3: Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø­ÙØ¸Ø© Ù„Ù„ØªØ·ÙˆÙŠØ±

```bash
# Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­ÙØ¸Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ·ÙˆÙŠØ±
solana-keygen new --outfile ~/.config/solana/devnet-wallet.json

# Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„Ø´Ø¨ÙƒØ© Devnet
solana config set --url https://api.devnet.solana.com

# Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ SOL Ù…Ø¬Ø§Ù†ÙŠ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
solana airdrop 2
```

### Step 1.4: Ø¥Ø¹Ø¯Ø§Ø¯ Environment Variables

```bash
cd /Users/s/Solana-SynapsePay

# Ù†Ø³Ø® Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
cp .env.example .env

# ØªØ­Ø±ÙŠØ± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
open .env
```

**Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ `.env`:**

```env
# Solana
SOLANA_NETWORK=devnet
SOLANA_RPC_URL=https://api.devnet.solana.com

# Facilitator - Ù…ÙØªØ§Ø­ Ø§Ù„Ù…Ø­ÙØ¸Ø© (Base58)
FACILITATOR_PRIVATE_KEY=<your_base58_private_key>

# AI (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„Ù„Ù€ Demo)
OPENAI_API_KEY=sk-your-key-here

# Frontend
VITE_SOLANA_NETWORK=devnet
VITE_FACILITATOR_URL=http://localhost:8403
VITE_RESOURCE_SERVER_URL=http://localhost:8404
```

### Step 1.5: ØªØ«Ø¨ÙŠØª Dependencies

```bash
cd /Users/s/Solana-SynapsePay

# ØªØ«Ø¨ÙŠØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ dependencies
bun install

# Ø£Ùˆ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… npm
npm install
```

---

# â›“ï¸ Phase 2: Anchor Programs (Smart Contracts)
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 2-3 Ø³Ø§Ø¹Ø§Øª
## ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯: `programs/`

### Step 2.1: Registry Program - ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù€ Agents

**Ø§Ù„Ù…Ù„Ù:** `programs/synapsepay-registry/src/lib.rs`

```rust
use anchor_lang::prelude::*;

declare_id!("SYNRegistry111111111111111111111111111111111");

#[program]
pub mod synapsepay_registry {
    use super::*;

    pub fn register_agent(
        ctx: Context<RegisterAgent>,
        agent_id: String,
        metadata_cid: String,
        price: u64,
        category: AgentCategory,
    ) -> Result<()> {
        let agent = &mut ctx.accounts.agent;
        let clock = Clock::get()?;
        
        agent.owner = ctx.accounts.owner.key();
        agent.agent_id = agent_id;
        agent.metadata_cid = metadata_cid;
        agent.price = price;
        agent.category = category;
        agent.total_runs = 0;
        agent.total_earned = 0;
        agent.rating = 0;
        agent.is_active = true;
        agent.created_at = clock.unix_timestamp;
        agent.updated_at = clock.unix_timestamp;
        
        Ok(())
    }

    pub fn update_agent(
        ctx: Context<UpdateAgent>,
        new_metadata_cid: Option<String>,
        new_price: Option<u64>,
    ) -> Result<()> {
        let agent = &mut ctx.accounts.agent;
        let clock = Clock::get()?;
        
        require!(agent.owner == ctx.accounts.owner.key(), RegistryError::Unauthorized);
        
        if let Some(cid) = new_metadata_cid {
            agent.metadata_cid = cid;
        }
        if let Some(price) = new_price {
            agent.price = price;
        }
        agent.updated_at = clock.unix_timestamp;
        
        Ok(())
    }

    pub fn deactivate_agent(ctx: Context<DeactivateAgent>) -> Result<()> {
        let agent = &mut ctx.accounts.agent;
        require!(agent.owner == ctx.accounts.owner.key(), RegistryError::Unauthorized);
        agent.is_active = false;
        Ok(())
    }

    pub fn increment_runs(ctx: Context<IncrementRuns>, earned: u64) -> Result<()> {
        let agent = &mut ctx.accounts.agent;
        agent.total_runs += 1;
        agent.total_earned += earned;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(agent_id: String)]
pub struct RegisterAgent<'info> {
    #[account(
        init,
        payer = owner,
        space = 8 + Agent::INIT_SPACE,
        seeds = [b"agent", agent_id.as_bytes()],
        bump
    )]
    pub agent: Account<'info, Agent>,
    
    #[account(mut)]
    pub owner: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateAgent<'info> {
    #[account(mut)]
    pub agent: Account<'info, Agent>,
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct DeactivateAgent<'info> {
    #[account(mut)]
    pub agent: Account<'info, Agent>,
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct IncrementRuns<'info> {
    #[account(mut)]
    pub agent: Account<'info, Agent>,
    /// CHECK: Authority account
    pub authority: Signer<'info>,
}

#[account]
#[derive(InitSpace)]
pub struct Agent {
    pub owner: Pubkey,
    #[max_len(64)]
    pub agent_id: String,
    #[max_len(64)]
    pub metadata_cid: String,
    pub price: u64,
    pub category: AgentCategory,
    pub total_runs: u64,
    pub total_earned: u64,
    pub rating: u16,
    pub is_active: bool,
    pub created_at: i64,
    pub updated_at: i64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq, InitSpace)]
pub enum AgentCategory {
    AI,
    IoT,
    Automation,
    Utility,
    Trading,
    NFT,
}

#[error_code]
pub enum RegistryError {
    #[msg("Unauthorized")]
    Unauthorized,
}
```

### Step 2.2: Payments Program - Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª

**Ø§Ù„Ù…Ù„Ù:** `programs/synapsepay-payments/src/instructions/` (ØªØ­ØªØ§Ø¬ Ù…Ù„ÙØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø©)

**Ø§Ù„Ù…Ù„Ù: `create_invoice.rs`**

```rust
use anchor_lang::prelude::*;
use crate::state::*;

pub fn handler(
    ctx: Context<CreateInvoice>,
    agent_id: String,
    amount: u64,
    expires_at: i64,
) -> Result<()> {
    let invoice = &mut ctx.accounts.invoice;
    let clock = Clock::get()?;
    
    invoice.invoice_id = ctx.accounts.invoice.key();
    invoice.payer = ctx.accounts.payer.key();
    invoice.recipient = ctx.accounts.recipient.key();
    invoice.agent_id = agent_id;
    invoice.amount = amount;
    invoice.state = PaymentState::InvoiceCreated;
    invoice.expires_at = expires_at;
    invoice.created_at = clock.unix_timestamp;
    invoice.nonce = clock.unix_timestamp as u64;
    
    Ok(())
}

#[derive(Accounts)]
#[instruction(agent_id: String)]
pub struct CreateInvoice<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + Invoice::INIT_SPACE,
        seeds = [b"invoice", payer.key().as_ref(), agent_id.as_bytes()],
        bump
    )]
    pub invoice: Account<'info, Invoice>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    /// CHECK: Recipient wallet
    pub recipient: AccountInfo<'info>,
    
    pub system_program: Program<'info, System>,
}
```

**Ø§Ù„Ù…Ù„Ù: `settle_payment.rs`**

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};
use crate::state::*;

pub fn handler(
    ctx: Context<SettlePayment>,
    _signature: [u8; 64],
) -> Result<()> {
    let invoice = &mut ctx.accounts.invoice;
    let clock = Clock::get()?;
    
    // Verify not expired
    require!(clock.unix_timestamp < invoice.expires_at, PaymentError::InvoiceExpired);
    
    // Verify state
    require!(
        invoice.state == PaymentState::InvoiceCreated,
        PaymentError::InvalidState
    );
    
    // Transfer USDC from payer to escrow
    let cpi_accounts = Transfer {
        from: ctx.accounts.payer_token.to_account_info(),
        to: ctx.accounts.escrow_token.to_account_info(),
        authority: ctx.accounts.payer.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, invoice.amount)?;
    
    // Update state
    invoice.state = PaymentState::Pending;
    
    Ok(())
}

#[derive(Accounts)]
pub struct SettlePayment<'info> {
    #[account(mut)]
    pub invoice: Account<'info, Invoice>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    #[account(mut)]
    pub payer_token: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub escrow_token: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

#[error_code]
pub enum PaymentError {
    #[msg("Invoice expired")]
    InvoiceExpired,
    #[msg("Invalid payment state")]
    InvalidState,
    #[msg("Invalid signature")]
    InvalidSignature,
    #[msg("Nonce already used")]
    NonceAlreadyUsed,
}
```

### Step 2.3: Build Ùˆ Deploy Ø§Ù„Ø¨Ø±Ø§Ù…Ø¬

```bash
cd /Users/s/Solana-SynapsePay

# Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø±Ø§Ù…Ø¬
anchor build

# Deploy Ø¹Ù„Ù‰ Devnet
anchor deploy --provider.cluster devnet

# Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Program IDs
solana program show --programs
```

### Step 2.4: ØªØ­Ø¯ÙŠØ« Program IDs

Ø¨Ø¹Ø¯ Ø§Ù„Ù€ DeployØŒ Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ IDs ÙÙŠ:
- `Anchor.toml`
- `.env`
- `apps/web/src/config/solana.ts`

---

# ğŸ“¦ Phase 3: X402 Protocol Library
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 1-2 Ø³Ø§Ø¹Ø©
## ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯: `packages/x402-solana/`

### Step 3.1: Types Definition

**Ø§Ù„Ù…Ù„Ù:** `packages/x402-solana/src/types.ts`

```typescript
import { PublicKey } from '@solana/web3.js';

export interface X402PaymentPayload {
  version: string;
  paymentType: 'solana';
  network: 'devnet' | 'mainnet-beta';
  payload: SolanaPaymentPayload;
}

export interface SolanaPaymentPayload {
  paymentId: string;
  payer: string;
  recipient: string;
  amount: string;
  tokenMint: string;
  agentId: string;
  taskMetadata?: Record<string, any>;
  expiresAt: number;
  nonce: number;
  transactionSignature?: {
    signature: string;
    publicKey: string;
  };
  paymentIntentSignature?: {
    signature: string;
    nonce: number;
  };
}

export interface InvoiceRequest {
  agentId: string;
  amount: string;
  payer: string;
  recipient?: string;
  taskMetadata?: Record<string, any>;
}

export interface InvoiceResponse {
  invoiceId: string;
  amount: string;
  currency: string;
  recipient: string;
  expiresAt: number;
  network: string;
  paymentPayload: X402PaymentPayload;
}

export interface SettlementResponse {
  success: boolean;
  txSignature: string;
  slot: number;
  receiptId?: string;
}

export type PaymentState = 
  | 'idle'
  | 'creating_invoice'
  | 'awaiting_permit'
  | 'awaiting_intent'
  | 'verifying'
  | 'settling'
  | 'executing'
  | 'completed'
  | 'failed';
```

### Step 3.2: Payload Encoding/Decoding

**Ø§Ù„Ù…Ù„Ù:** `packages/x402-solana/src/payload.ts`

```typescript
import { X402PaymentPayload, SolanaPaymentPayload } from './types';
import bs58 from 'bs58';

export function encodePayload(payload: X402PaymentPayload): string {
  const json = JSON.stringify(payload);
  const bytes = new TextEncoder().encode(json);
  return Buffer.from(bytes).toString('base64');
}

export function decodePayload(encoded: string): X402PaymentPayload {
  const bytes = Buffer.from(encoded, 'base64');
  const json = new TextDecoder().decode(bytes);
  return JSON.parse(json) as X402PaymentPayload;
}

export function createPaymentPayload(
  params: {
    paymentId: string;
    payer: string;
    recipient: string;
    amount: string;
    agentId: string;
    tokenMint: string;
    network: 'devnet' | 'mainnet-beta';
    expiresAt?: number;
    taskMetadata?: Record<string, any>;
  }
): X402PaymentPayload {
  const now = Date.now();
  
  return {
    version: '1.0',
    paymentType: 'solana',
    network: params.network,
    payload: {
      paymentId: params.paymentId,
      payer: params.payer,
      recipient: params.recipient,
      amount: params.amount,
      tokenMint: params.tokenMint,
      agentId: params.agentId,
      taskMetadata: params.taskMetadata,
      expiresAt: params.expiresAt || now + 5 * 60 * 1000, // 5 minutes
      nonce: now,
    },
  };
}

export function createXPaymentHeader(payload: X402PaymentPayload): string {
  return encodePayload(payload);
}

export function parseXPaymentHeader(header: string): X402PaymentPayload | null {
  try {
    return decodePayload(header);
  } catch {
    return null;
  }
}
```

### Step 3.3: Signature Functions

**Ø§Ù„Ù…Ù„Ù:** `packages/x402-solana/src/signatures.ts`

```typescript
import { Keypair, PublicKey } from '@solana/web3.js';
import nacl from 'tweetnacl';
import bs58 from 'bs58';

export interface SignedMessage {
  signature: string;
  publicKey: string;
  message: string;
}

export async function signPaymentIntent(
  message: Uint8Array,
  signMessage: (message: Uint8Array) => Promise<Uint8Array>,
  publicKey: PublicKey
): Promise<SignedMessage> {
  const signature = await signMessage(message);
  
  return {
    signature: bs58.encode(signature),
    publicKey: publicKey.toBase58(),
    message: bs58.encode(message),
  };
}

export function verifySignature(
  signature: string,
  message: string,
  publicKey: string
): boolean {
  try {
    const signatureBytes = bs58.decode(signature);
    const messageBytes = bs58.decode(message);
    const publicKeyBytes = bs58.decode(publicKey);
    
    return nacl.sign.detached.verify(
      messageBytes,
      signatureBytes,
      publicKeyBytes
    );
  } catch {
    return false;
  }
}

export function createPaymentIntentMessage(
  paymentId: string,
  amount: string,
  recipient: string,
  nonce: number
): Uint8Array {
  const message = `SynapsePay Payment Intent\n` +
    `Payment ID: ${paymentId}\n` +
    `Amount: ${amount} USDC\n` +
    `Recipient: ${recipient}\n` +
    `Nonce: ${nonce}`;
  
  return new TextEncoder().encode(message);
}
```

### Step 3.4: Middleware for Backend

**Ø§Ù„Ù…Ù„Ù:** `packages/x402-solana/src/middleware.ts`

```typescript
import { Context, Next } from 'hono';
import { parseXPaymentHeader } from './payload';
import { verifySignature } from './signatures';
import { X402PaymentPayload } from './types';

export interface X402Context {
  payment?: X402PaymentPayload;
  isValid: boolean;
  error?: string;
}

export async function x402Middleware(c: Context, next: Next) {
  const xPaymentHeader = c.req.header('X-PAYMENT');
  
  if (!xPaymentHeader) {
    // Return 402 Payment Required
    return c.json({
      error: 'Payment Required',
      code: 402,
      message: 'X-PAYMENT header is required',
    }, 402);
  }
  
  const payload = parseXPaymentHeader(xPaymentHeader);
  
  if (!payload) {
    return c.json({
      error: 'Invalid Payment',
      code: 400,
      message: 'Could not parse X-PAYMENT header',
    }, 400);
  }
  
  // Verify expiry
  if (Date.now() > payload.payload.expiresAt) {
    return c.json({
      error: 'Payment Expired',
      code: 400,
      message: 'Payment has expired',
    }, 400);
  }
  
  // Verify signatures if present
  if (payload.payload.paymentIntentSignature) {
    const isValid = verifySignature(
      payload.payload.paymentIntentSignature.signature,
      payload.payload.paymentId,
      payload.payload.payer
    );
    
    if (!isValid) {
      return c.json({
        error: 'Invalid Signature',
        code: 401,
        message: 'Payment signature verification failed',
      }, 401);
    }
  }
  
  // Attach payment to context
  c.set('x402Payment', payload);
  
  await next();
}

export function getPaymentFromContext(c: Context): X402PaymentPayload | undefined {
  return c.get('x402Payment');
}
```

### Step 3.5: Export Index

**Ø§Ù„Ù…Ù„Ù:** `packages/x402-solana/src/index.ts`

```typescript
export * from './types';
export * from './payload';
export * from './signatures';
export * from './middleware';
```

---

# ğŸ”§ Phase 4: Backend Services
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 2-3 Ø³Ø§Ø¹Ø§Øª
## ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª: `apps/x402-facilitator/` Ùˆ `apps/resource-server/`

### Step 4.1: X402 Facilitator - Main Server

**Ø§Ù„Ù…Ù„Ù:** `apps/x402-facilitator/src/server.ts`

```typescript
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { invoiceRoutes } from './routes/invoice';
import { verifyRoutes } from './routes/verify';
import { settleRoutes } from './routes/settle';

const app = new Hono();

// Middleware
app.use('*', logger());
app.use('*', cors({
  origin: ['http://localhost:5173', 'http://localhost:5174'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'X-PAYMENT'],
}));

// Health check
app.get('/health', (c) => {
  return c.json({
    status: 'ok',
    service: 'x402-facilitator',
    timestamp: new Date().toISOString(),
  });
});

// Routes
app.route('/invoice', invoiceRoutes);
app.route('/verify', verifyRoutes);
app.route('/settle', settleRoutes);

// 404 handler
app.notFound((c) => {
  return c.json({ error: 'Not Found' }, 404);
});

// Error handler
app.onError((err, c) => {
  console.error('Server error:', err);
  return c.json({ error: 'Internal Server Error' }, 500);
});

const port = process.env.FACILITATOR_PORT || 8403;

console.log(`ğŸš€ X402 Facilitator running on port ${port}`);

export default {
  port,
  fetch: app.fetch,
};
```

### Step 4.2: Invoice Route

**Ø§Ù„Ù…Ù„Ù:** `apps/x402-facilitator/src/routes/invoice.ts`

```typescript
import { Hono } from 'hono';
import { createPaymentPayload, encodePayload } from '@synapsepay/x402-solana';
import { v4 as uuidv4 } from 'uuid';
import bs58 from 'bs58';

const app = new Hono();

// Agent prices (in USDC, 6 decimals)
const AGENT_PRICES: Record<string, number> = {
  'pdf-summarizer-v1': 50000,      // 0.05 USDC
  'image-editor-v1': 100000,       // 0.10 USDC
  'nft-minter-v1': 250000,         // 0.25 USDC
  'code-debugger-v1': 80000,       // 0.08 USDC
  'ugv-rover-01': 100000,          // 0.10 USDC
  'smart-led-array': 50000,        // 0.05 USDC
};

// Agent recipients (owner wallets)
const AGENT_RECIPIENTS: Record<string, string> = {
  'pdf-summarizer-v1': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
  'image-editor-v1': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
  'nft-minter-v1': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
  'code-debugger-v1': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
  'ugv-rover-01': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
  'smart-led-array': 'HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH',
};

const USDC_MINT = {
  devnet: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
  'mainnet-beta': 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
};

app.post('/', async (c) => {
  try {
    const body = await c.req.json();
    const { agentId, payer, taskMetadata } = body;
    
    if (!agentId || !payer) {
      return c.json({ error: 'Missing required fields' }, 400);
    }
    
    const amount = AGENT_PRICES[agentId];
    if (!amount) {
      return c.json({ error: 'Unknown agent' }, 404);
    }
    
    const recipient = AGENT_RECIPIENTS[agentId];
    const network = (process.env.SOLANA_NETWORK || 'devnet') as 'devnet' | 'mainnet-beta';
    const paymentId = bs58.encode(Buffer.from(uuidv4().replace(/-/g, ''), 'hex'));
    
    const payload = createPaymentPayload({
      paymentId,
      payer,
      recipient,
      amount: amount.toString(),
      agentId,
      tokenMint: USDC_MINT[network],
      network,
      taskMetadata,
    });
    
    return c.json({
      invoiceId: paymentId,
      amount: amount.toString(),
      amountDisplay: `${(amount / 1_000_000).toFixed(2)} USDC`,
      currency: 'USDC',
      recipient,
      expiresAt: payload.payload.expiresAt,
      network,
      paymentPayload: payload,
      xPaymentHeader: encodePayload(payload),
    });
  } catch (error) {
    console.error('Invoice creation error:', error);
    return c.json({ error: 'Failed to create invoice' }, 500);
  }
});

app.get('/status/:invoiceId', async (c) => {
  const invoiceId = c.req.param('invoiceId');
  
  // In production, fetch from database
  // For demo, return mock status
  return c.json({
    invoiceId,
    status: 'pending',
    createdAt: new Date().toISOString(),
  });
});

export { app as invoiceRoutes };
```

### Step 4.3: Verify Route

**Ø§Ù„Ù…Ù„Ù:** `apps/x402-facilitator/src/routes/verify.ts`

```typescript
import { Hono } from 'hono';
import { parseXPaymentHeader, verifySignature } from '@synapsepay/x402-solana';

const app = new Hono();

app.post('/', async (c) => {
  try {
    const body = await c.req.json();
    const { xPaymentHeader } = body;
    
    if (!xPaymentHeader) {
      return c.json({ valid: false, error: 'Missing X-PAYMENT header' }, 400);
    }
    
    const payload = parseXPaymentHeader(xPaymentHeader);
    if (!payload) {
      return c.json({ valid: false, error: 'Invalid payload format' }, 400);
    }
    
    // Check expiry
    if (Date.now() > payload.payload.expiresAt) {
      return c.json({ valid: false, error: 'Payment expired' }, 400);
    }
    
    // Verify signature if present
    if (payload.payload.paymentIntentSignature) {
      const isValid = verifySignature(
        payload.payload.paymentIntentSignature.signature,
        payload.payload.paymentId,
        payload.payload.payer
      );
      
      if (!isValid) {
        return c.json({ valid: false, error: 'Invalid signature' }, 401);
      }
    }
    
    return c.json({
      valid: true,
      payload: payload.payload,
      expiresIn: payload.payload.expiresAt - Date.now(),
    });
  } catch (error) {
    console.error('Verification error:', error);
    return c.json({ valid: false, error: 'Verification failed' }, 500);
  }
});

export { app as verifyRoutes };
```

### Step 4.4: Settle Route

**Ø§Ù„Ù…Ù„Ù:** `apps/x402-facilitator/src/routes/settle.ts`

```typescript
import { Hono } from 'hono';
import { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';
import { 
  getAssociatedTokenAddress, 
  createTransferInstruction,
  getAccount
} from '@solana/spl-token';
import { parseXPaymentHeader } from '@synapsepay/x402-solana';
import bs58 from 'bs58';

const app = new Hono();

// Initialize connection
const connection = new Connection(
  process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com',
  'confirmed'
);

// Facilitator wallet (pays gas, gets refunded from payment)
let facilitatorKeypair: Keypair | null = null;

try {
  const privateKey = process.env.FACILITATOR_PRIVATE_KEY;
  if (privateKey) {
    facilitatorKeypair = Keypair.fromSecretKey(bs58.decode(privateKey));
    console.log('Facilitator wallet:', facilitatorKeypair.publicKey.toBase58());
  }
} catch (e) {
  console.warn('Facilitator keypair not configured');
}

app.post('/', async (c) => {
  try {
    const body = await c.req.json();
    const { xPaymentHeader, signedTransaction } = body;
    
    if (!xPaymentHeader) {
      return c.json({ success: false, error: 'Missing payment header' }, 400);
    }
    
    const payload = parseXPaymentHeader(xPaymentHeader);
    if (!payload) {
      return c.json({ success: false, error: 'Invalid payload' }, 400);
    }
    
    // Check expiry
    if (Date.now() > payload.payload.expiresAt) {
      return c.json({ success: false, error: 'Payment expired' }, 400);
    }
    
    // For demo mode - simulate successful settlement
    if (!facilitatorKeypair || !signedTransaction) {
      console.log('Demo mode: Simulating settlement');
      
      return c.json({
        success: true,
        mode: 'demo',
        txSignature: `demo_${Date.now()}_${Math.random().toString(36).slice(2)}`,
        slot: Math.floor(Math.random() * 1000000) + 250000000,
        amount: payload.payload.amount,
        payer: payload.payload.payer,
        recipient: payload.payload.recipient,
        settledAt: new Date().toISOString(),
      });
    }
    
    // Real settlement flow
    const transaction = Transaction.from(Buffer.from(signedTransaction, 'base64'));
    
    // Send transaction
    const txSignature = await connection.sendRawTransaction(
      transaction.serialize(),
      { skipPreflight: false }
    );
    
    // Confirm transaction
    const confirmation = await connection.confirmTransaction(txSignature, 'confirmed');
    
    if (confirmation.value.err) {
      return c.json({ 
        success: false, 
        error: 'Transaction failed', 
        details: confirmation.value.err 
      }, 400);
    }
    
    return c.json({
      success: true,
      txSignature,
      slot: confirmation.context.slot,
      amount: payload.payload.amount,
      payer: payload.payload.payer,
      recipient: payload.payload.recipient,
      settledAt: new Date().toISOString(),
      explorerUrl: `https://explorer.solana.com/tx/${txSignature}?cluster=devnet`,
    });
    
  } catch (error) {
    console.error('Settlement error:', error);
    return c.json({ 
      success: false, 
      error: 'Settlement failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, 500);
  }
});

export { app as settleRoutes };
```

### Step 4.5: Resource Server - AI Agent Execution

**Ø§Ù„Ù…Ù„Ù:** `apps/resource-server/src/server.ts`

```typescript
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { x402Middleware, getPaymentFromContext } from '@synapsepay/x402-solana';

const app = new Hono();

// Middleware
app.use('*', logger());
app.use('*', cors({
  origin: ['http://localhost:5173', 'http://localhost:5174'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'X-PAYMENT'],
}));

// Health check (no payment required)
app.get('/health', (c) => {
  return c.json({
    status: 'ok',
    service: 'resource-server',
    timestamp: new Date().toISOString(),
  });
});

// List agents (no payment required)
app.get('/agents', (c) => {
  return c.json({
    agents: [
      {
        id: 'pdf-summarizer-v1',
        name: 'PDF Summarizer',
        description: 'AI-powered PDF summary extraction',
        price: 50000,
        priceDisplay: '0.05 USDC',
        category: 'AI',
        rating: 4.8,
        totalRuns: 1250,
      },
      {
        id: 'image-editor-v1',
        name: 'Image Editor',
        description: 'Remove background, resize, apply filters',
        price: 100000,
        priceDisplay: '0.10 USDC',
        category: 'AI',
        rating: 4.6,
        totalRuns: 890,
      },
      {
        id: 'nft-minter-v1',
        name: 'NFT Minter',
        description: 'Generate and mint NFT from image',
        price: 250000,
        priceDisplay: '0.25 USDC',
        category: 'NFT',
        rating: 4.9,
        totalRuns: 650,
      },
      {
        id: 'ugv-rover-01',
        name: 'UGV Rover 01',
        description: 'Control physical robot with live camera',
        price: 100000,
        priceDisplay: '0.10 USDC',
        category: 'IoT',
        duration: 600, // 10 minutes
        rating: 4.7,
        totalRuns: 320,
      },
    ],
  });
});

// Execute agent (payment required)
app.post('/agent/execute', x402Middleware, async (c) => {
  const payment = getPaymentFromContext(c);
  
  if (!payment) {
    return c.json({ error: 'Payment not found' }, 402);
  }
  
  const body = await c.req.json();
  const { agentId, taskParams } = body;
  
  // Simulate AI execution
  console.log(`Executing agent: ${agentId}`);
  console.log(`Payment: ${payment.payload.amount} from ${payment.payload.payer}`);
  
  // Simulate processing time
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Return mock result based on agent
  let result;
  switch (agentId) {
    case 'pdf-summarizer-v1':
      result = {
        summary: 'This document discusses the key aspects of blockchain technology...',
        keyPoints: [
          'Decentralization enables trustless transactions',
          'Smart contracts automate complex processes',
          'Micropayments become economically viable',
        ],
        wordCount: 150,
      };
      break;
    case 'nft-minter-v1':
      result = {
        mintAddress: 'NFT' + Math.random().toString(36).slice(2, 10).toUpperCase(),
        metadataUri: 'https://arweave.net/example-metadata',
        explorerUrl: 'https://explorer.solana.com/address/...',
      };
      break;
    default:
      result = {
        success: true,
        message: `Agent ${agentId} executed successfully`,
        timestamp: new Date().toISOString(),
      };
  }
  
  return c.json({
    taskId: `task_${Date.now()}`,
    status: 'completed',
    result,
    executionTime: 2000,
    payment: {
      amount: payment.payload.amount,
      payer: payment.payload.payer,
    },
  });
});

// Device command (for IoT)
app.post('/device/command', x402Middleware, async (c) => {
  const payment = getPaymentFromContext(c);
  const body = await c.req.json();
  const { deviceId, command, params } = body;
  
  console.log(`Device command: ${command} to ${deviceId}`);
  
  // Simulate device response
  return c.json({
    success: true,
    deviceId,
    command,
    response: 'ACK',
    timestamp: new Date().toISOString(),
  });
});

const port = process.env.RESOURCE_SERVER_PORT || 8404;

console.log(`ğŸ¤– Resource Server running on port ${port}`);

export default {
  port,
  fetch: app.fetch,
};
```

### Step 4.6: ØªØ´ØºÙŠÙ„ Backend Services

```bash
# Terminal 1: Facilitator
cd /Users/s/Solana-SynapsePay/apps/x402-facilitator
bun run dev

# Terminal 2: Resource Server
cd /Users/s/Solana-SynapsePay/apps/resource-server
bun run dev
```

---

# ğŸ¨ Phase 5: Frontend Integration
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 2-3 Ø³Ø§Ø¹Ø§Øª
## ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯: `apps/web/src/`

### Step 5.1: Payment Hook

**Ø§Ù„Ù…Ù„Ù:** `apps/web/src/hooks/usePayment.ts`

```typescript
import { useState, useCallback } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { 
  createPaymentIntentMessage, 
  signPaymentIntent,
  createXPaymentHeader 
} from '@synapsepay/x402-solana';

export type PaymentState = 
  | 'idle'
  | 'creating_invoice'
  | 'awaiting_permit'
  | 'awaiting_intent'
  | 'settling'
  | 'executing'
  | 'completed'
  | 'failed';

interface UsePaymentOptions {
  facilitatorUrl: string;
  resourceServerUrl: string;
}

interface PaymentResult {
  success: boolean;
  txSignature?: string;
  result?: any;
  error?: string;
}

export function usePayment(options: UsePaymentOptions) {
  const { publicKey, signMessage } = useWallet();
  const [state, setState] = useState<PaymentState>('idle');
  const [error, setError] = useState<string | null>(null);
  const [logs, setLogs] = useState<string[]>([]);

  const addLog = (message: string) => {
    const timestamp = new Date().toLocaleTimeString();
    setLogs(prev => [...prev, `[${timestamp}] ${message}`]);
  };

  const executePayment = useCallback(async (
    agentId: string,
    taskParams?: Record<string, any>
  ): Promise<PaymentResult> => {
    if (!publicKey || !signMessage) {
      return { success: false, error: 'Wallet not connected' };
    }

    try {
      setError(null);
      setLogs([]);
      
      // Step 1: Create Invoice
      setState('creating_invoice');
      addLog('Creating payment invoice...');
      
      const invoiceRes = await fetch(`${options.facilitatorUrl}/invoice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          agentId,
          payer: publicKey.toBase58(),
          taskMetadata: taskParams,
        }),
      });
      
      if (!invoiceRes.ok) {
        throw new Error('Failed to create invoice');
      }
      
      const invoice = await invoiceRes.json();
      addLog(`âœ“ Invoice created: ${invoice.amountDisplay}`);
      
      // Step 2: Sign Permit (USDC approval)
      setState('awaiting_permit');
      addLog('Requesting USDC-SPL token approval signature...');
      
      // In real implementation, this would be a Solana transaction
      // For demo, we simulate with a message signature
      const permitMessage = `Approve ${invoice.amountDisplay} for ${agentId}`;
      const permitBytes = new TextEncoder().encode(permitMessage);
      
      await signMessage(permitBytes);
      addLog('âœ“ Permit signature received');
      
      // Step 3: Sign Payment Intent
      setState('awaiting_intent');
      addLog('Requesting payment intent signature...');
      
      const intentMessage = createPaymentIntentMessage(
        invoice.invoiceId,
        invoice.amountDisplay,
        invoice.recipient,
        Date.now()
      );
      
      const intentSignature = await signMessage(intentMessage);
      addLog('âœ“ Payment intent signed');
      
      // Step 4: Settle Payment
      setState('settling');
      addLog('Submitting to Solana network...');
      
      const settleRes = await fetch(`${options.facilitatorUrl}/settle`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          xPaymentHeader: invoice.xPaymentHeader,
          // In real implementation, include signed transaction
        }),
      });
      
      if (!settleRes.ok) {
        throw new Error('Settlement failed');
      }
      
      const settlement = await settleRes.json();
      addLog(`âœ“ Payment settled: ${invoice.amountDisplay} transferred`);
      
      // Step 5: Execute Agent
      setState('executing');
      addLog('Executing AI agent...');
      
      const executeRes = await fetch(`${options.resourceServerUrl}/agent/execute`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-PAYMENT': invoice.xPaymentHeader,
        },
        body: JSON.stringify({
          agentId,
          taskParams,
        }),
      });
      
      if (!executeRes.ok) {
        throw new Error('Agent execution failed');
      }
      
      const result = await executeRes.json();
      addLog('âœ“ Task completed successfully');
      
      setState('completed');
      
      return {
        success: true,
        txSignature: settlement.txSignature,
        result: result.result,
      };
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setState('failed');
      setError(errorMessage);
      addLog(`âœ— Error: ${errorMessage}`);
      return { success: false, error: errorMessage };
    }
  }, [publicKey, signMessage, options]);

  const reset = useCallback(() => {
    setState('idle');
    setError(null);
    setLogs([]);
  }, []);

  return {
    state,
    error,
    logs,
    executePayment,
    reset,
    isProcessing: !['idle', 'completed', 'failed'].includes(state),
  };
}
```

### Step 5.2: Agent Hook

**Ø§Ù„Ù…Ù„Ù:** `apps/web/src/hooks/useAgents.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';

interface Agent {
  id: string;
  name: string;
  description: string;
  price: number;
  priceDisplay: string;
  category: string;
  rating: number;
  totalRuns: number;
  duration?: number;
}

export function useAgents(resourceServerUrl: string) {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchAgents = useCallback(async () => {
    try {
      setLoading(true);
      const res = await fetch(`${resourceServerUrl}/agents`);
      
      if (!res.ok) {
        throw new Error('Failed to fetch agents');
      }
      
      const data = await res.json();
      setAgents(data.agents);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [resourceServerUrl]);

  useEffect(() => {
    fetchAgents();
  }, [fetchAgents]);

  const getAgentById = useCallback((id: string) => {
    return agents.find(agent => agent.id === id);
  }, [agents]);

  const getAgentsByCategory = useCallback((category: string) => {
    return agents.filter(agent => agent.category === category);
  }, [agents]);

  return {
    agents,
    loading,
    error,
    refetch: fetchAgents,
    getAgentById,
    getAgentsByCategory,
  };
}
```

### Step 5.3: ØªØ­Ø¯ÙŠØ« Config

**Ø§Ù„Ù…Ù„Ù:** `apps/web/src/config/endpoints.ts`

```typescript
export const config = {
  facilitatorUrl: import.meta.env.VITE_FACILITATOR_URL || 'http://localhost:8403',
  resourceServerUrl: import.meta.env.VITE_RESOURCE_SERVER_URL || 'http://localhost:8404',
  actionsApiUrl: import.meta.env.VITE_ACTIONS_API_URL || 'http://localhost:8405',
  
  solana: {
    network: import.meta.env.VITE_SOLANA_NETWORK || 'devnet',
    rpcUrl: import.meta.env.VITE_SOLANA_RPC_URL || 'https://api.devnet.solana.com',
  },
  
  tokens: {
    usdc: {
      devnet: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
      'mainnet-beta': 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    },
  },
};
```

---

# ğŸ§ª Phase 6: Testing & Demo
## Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©: 1-2 Ø³Ø§Ø¹Ø©

### Step 6.1: ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø¯Ù…Ø§Øª

```bash
# Terminal 1: Frontend
cd /Users/s/Solana-SynapsePay/apps/web
npm run dev
# â†’ http://localhost:5174

# Terminal 2: Facilitator
cd /Users/s/Solana-SynapsePay/apps/x402-facilitator
bun run dev
# â†’ http://localhost:8403

# Terminal 3: Resource Server
cd /Users/s/Solana-SynapsePay/apps/resource-server
bun run dev
# â†’ http://localhost:8404
```

### Step 6.2: Ø§Ø®ØªØ¨Ø§Ø± API Endpoints

```bash
# Test Facilitator Health
curl http://localhost:8403/health

# Test Create Invoice
curl -X POST http://localhost:8403/invoice \
  -H "Content-Type: application/json" \
  -d '{
    "agentId": "pdf-summarizer-v1",
    "payer": "your-wallet-address"
  }'

# Test Resource Server
curl http://localhost:8404/agents
```

### Step 6.3: Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„

1. Ø§ÙØªØ­ `http://localhost:5174`
2. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ **Connect Wallet** ÙˆØ§ØªØµÙ„ Ø¨Ù€ Phantom
3. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ **IoT Devices** â†’ **UGV Rover 01**
4. Ø§Ø¶ØºØ· **Initialize Payment Sequence**
5. ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚ÙŠØ¹Ø§Øª ÙÙŠ Phantom
6. Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø²Ø±Ø§Ø± WASD Ù„Ù„ØªØ­ÙƒÙ…

---

# ğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ø®Ø·Ø©

## Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ

| Ø§Ù„Ù…Ø±Ø­Ù„Ø© | Ø§Ù„Ù…Ø¯Ø© | Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª |
|---------|-------|----------|
| Phase 1: Environment | 30 mins | Solana CLI, Anchor, Dependencies |
| Phase 2: Anchor Programs | 2-3 hrs | 3 Smart Contracts |
| Phase 3: X402 Library | 1-2 hrs | TypeScript Package |
| Phase 4: Backend | 2-3 hrs | Facilitator + Resource Server |
| Phase 5: Frontend | 2-3 hrs | Hooks + Integration |
| Phase 6: Testing | 1-2 hrs | Working Demo |
| **Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹** | **9-14 Ø³Ø§Ø¹Ø§Øª** | **Full Implementation** |

## ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ù„Ù„ØªÙ†ÙÙŠØ°

```
1ï¸âƒ£  packages/x402-solana/          â† Ø£ÙˆÙ„Ø§Ù‹: Ø§Ù„Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
2ï¸âƒ£  programs/synapsepay-registry/  â† Ø«Ø§Ù†ÙŠØ§Ù‹: Registry Smart Contract
3ï¸âƒ£  programs/synapsepay-payments/  â† Ø«Ø§Ù„Ø«Ø§Ù‹: Payments Smart Contract
4ï¸âƒ£  apps/x402-facilitator/         â† Ø±Ø§Ø¨Ø¹Ø§Ù‹: Payment Gateway
5ï¸âƒ£  apps/resource-server/          â† Ø®Ø§Ù…Ø³Ø§Ù‹: AI Execution API
6ï¸âƒ£  apps/web/src/hooks/            â† Ø³Ø§Ø¯Ø³Ø§Ù‹: Frontend Hooks
7ï¸âƒ£  apps/web/src/components/       â† Ø³Ø§Ø¨Ø¹Ø§Ù‹: Component Integration
```

---

# âœ… Checklist Ù„Ù„Ù‡Ø§ÙƒØ§Ø«ÙˆÙ†

- [ ] Phase 1: Environment Setup
- [ ] Phase 2: Anchor Programs Deployed
- [ ] Phase 3: X402 Library Complete
- [ ] Phase 4: Backend Services Running
- [ ] Phase 5: Frontend Integration
- [ ] Phase 6: Testing Complete
- [ ] Demo Video Recorded (2-4 min)
- [ ] GitHub README Updated
- [ ] Submission Prepared

---

**ğŸ¯ Ø§Ù„Ù‡Ø¯Ù:** ØªØ³Ù„ÙŠÙ… Ù‚Ø¨Ù„ 14 Ø¯ÙŠØ³Ù…Ø¨Ø±!

**ğŸ“ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©:** Ø§Ø¨Ø¯Ø£ Ø¨Ø£ÙŠ Phase ÙˆØ³Ø£Ø³Ø§Ø¹Ø¯Ùƒ Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©!
